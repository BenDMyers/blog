---
title: "How (Not) to Build a Button"
date: 2019-09-28
description: Breaking down an antipattern is just a few clicks away!
cover: 'https://i.imgur.com/tdz9zBE.png'
coveralt: A chain of dominoes is stood up. The first one, which resembles the Domino's Pizza logo, is falling down and knocking the rest of the chain over.
emoji: ðŸ”²
tags: ["web accessibility", "accessibility", "web development"]
---

import Example1 from './Example1';
import Example2 from './Example2';
import Example3 from './Example3';

Buttons and hyperlinks are the cornerstones of the internet. Buttons allow users to interact with web content and links allow users to discover more content. They provide dynamic experiences and user autonomyâ€”two things the web could not live without. Because they're so central to the online experience, it's crucial that we get them right for everybody.

One common antipattern, especially in a framework-driven world, is adding click event listeners to HTML elements that aren't usually clickable. Let's call this the <dfn>clickable div antipattern</dfn>, even though the elements don't have to be `<div>` elements.

Here's a minimal example of a clickable div that uses the `onclick` attribute. The styles are adapted from [Bootstrap](https://getbootstrap.com/). Go ahead and click it!

<Example1 />

```html {numberLines: true}:title=index.html
<div class="btn" onclick="doSomething();">
    Click me!
</div>
```

<br/>

## The Allure of Clickable Divs

An <dfn>antipattern</dfn> is a *deceptively compelling* solution to a problem that proves to be ineffective or harmful in the long run. An antipattern's allure is what distinguishes it from bad habits or simply incorrect solutions.

So... what is the allure of clickable divs? Why would someone resort to `<div onclick>` when the `<button>` element has been around for two decades?

The main motivation I've seen for writing a clickable div is **quick-and-easy, yet total, control over design.**

Buttons have many different default styles across the full spectrum of browsers. Wrangling those defaults can feel like a pain, [as CSS-Tricks points out](https://css-tricks.com/overriding-default-button-styles/#article-header-id-1). What if you just want a button that looks like a link, or a nice floating action button? Do you *really* want to grapple with every browser on every device to make that work?

`<div>` elements come with a compelling promise: they're clean slates. `<div>`s don't come with any of the baggage that `<button>` elements do. They only come with one default style: `display: block;`. The developer can breathe a sigh of relief. They have their empty canvas of infinite flexibility.

Besides... the button works, right? You can click it!

## Remediation

When you create a clickable div, you're electing to implement your own button from scratch. Users expect certain behavior and functionality from their buttons. It's like a contract! Clickability is the most obvious clause of this contract, but there's more to buttons than that.

Good news, though! Our clickable div can be salvaged. We just need to make sure our clickable div follows the button contract. You can [read the Web Accessibility Initiative's layout of button expectations](https://www.w3.org/TR/wai-aria-practices/#button), or just follow along here.

### Focus

Not every person who comes to your site will use a mouse to navigate the page. Many users will instead use keyboard navigation. For instance, they might have a mobility impairment that restricts mouse manipulation, or they might not be able to see a cursor. They might not even be disabled. After all...

<Tweet tweetId="388733408576159744" />

The core tenet of keyboard navigation is managing <dfn>focus</dfn>: which *interactive* element is currently active and can be manipulated with the keyboard. Users can focus on form fields, links, and buttons. Users control the focus by pressing Tab to go forward and Shift+Tab to go backwards. Let's try tabbing to our first clickable div:

<Example1 />

The focus just skips straight from Adrian's tweet to the `tabindex` documentation link below, skipping our example clickable div in the process. It's clear this is a problem: how are keyboard-navigating users going to be able to interact with our button if they can't even *get* to it?

Fortunately, the fix is simple: we'll just specify the attribute `tabindex="0"` on our button div. Why `"0"`? [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) accepts three kinds of values:

* **`"0"`:** The element is inserted into the focus order based on where it is in the DOM.

* **A positive number:** The element is inserted into the focus order relative to other elements that have `tabindex` set. This generally makes your page harder for keyboard-navigating users to operate.

* **A negative number, usually `"-1"`:** The element is focusable programmatically (via JavaScript), but not via keyboard navigation. This does not solve our problem.

Let's add the `tabindex` and verify that our button is now tabbable.

<Example2 />

```html {numberLines: true}:title=index.html
<div class="btn" tabindex="0" onclick="doSomething();">
    Click me!
</div>
```

Now that you can actually tab to the button, it's a really good time to [make sure you set some focus styles](https://css-tricks.com/focusing-on-focus-styles/). That way, people know when they're focusing on your button.

### Key Presses

Keyboard navigators can now get to your button, but they still can't actually press it. The `onclick` handler that's been added only handles mouse clicks and mobile taps. A user who's navigating the page will expect to be able to press the button by clicking Enter or Space. (For links, by the way, only Enter will work)

This means we need to prime our clickable div to receive key press events:

<Example3 />

```js {numberLines: true}:title=button.js
const ENTER = 13;
const SPACE = 32;

// Select for your button and store it in `myButton`

myButton.addEventListener('keydown', function(event) {
    if(event.keyCode === ENTER || event.keyCode === SPACE) {
        event.preventDefault(); // Prevents unintentional form submissions, page scrollings, the like
        doSomething(event);
    }
});
```

### Role

### State

## Or...

## A Deeper Problem

## Prior Art

I'm by no means the first person to write something like this, and I won't be the last. I've listed a few resources I found immensely useful that you might, too:

* Vadim Makeev's ["When Is A Button Not A Button?"](https://www.smashingmagazine.com/2019/02/buttons-interfaces/) for *Smashing Magazine*
* Andy Bell's ["Introducing the Button element"](https://hankchizljaw.com/wrote/introducing-the-button-element/)
* Chris Coyier's ["Overriding Default Button Styles"](https://css-tricks.com/overriding-default-button-styles/) on CSS-Tricks