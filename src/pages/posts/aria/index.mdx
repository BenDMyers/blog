---
title: "What Is ARIA?"
date: 2019-11-25
description: A beginner's guide to navigating the multitude of ARIA attributes.
cover: 'https://i.imgur.com/jxuy6hS.png'
coveralt: A code snippet featuring a span that has the aria-label, role, and aria-checked attributes.
emoji: ðŸ”§
tags: ["web accessibility", "accessibility", "web development", "accessibility tree", "aria"]
---

<TOC />

It's no secret that websites are becoming increasingly complex.

[there are a lot of them](https://www.w3.org/TR/wai-aria-1.1/#state_prop_def)

<!-- <p><dfn>ARIA</dfn>, short for <i>Accessible Rich Internet Applications</i>, is a subset of HTML attributes that modify how assistive technologies such as screenreaders navigate your page. </p> -->

## Revisiting the Accessibility Tree

In [my last post](https://blog.benmyers.dev/accessibility-tree/), I introduced the <dfn>accessibility tree</dfn>: an alternative DOM that browsers create specifically for assistive technologies. These accessibility trees describe the page in terms of <dfn>accessible objects</dfn>: data structures provided by the operating system that represent different kinds of UI elements and controls, such as text nodes, checkboxes, or buttons.

Accessible objects describe UI elements as sets of properties. For example, properties that could describe a checkbox include:

* Whether it is checked or unchecked
* Its label
* The fact that it even is a checkbox, as opposed to other elements
* Whether it is in a disabled state
* Whether it can be focused with the keyboard
* Whether it is currently focused with the keyboard

We can break these attributes into four types:

1. **Name:** A label or identifier for this element. Names are used by screenreaders to announce an element, and speech recognition users can use names in their voice commands to target specific elements.
2. **Role:** What kind of UI element is this? Is it text, a button, a checkbox, or something else? This lays out expectations for what this element is doing here, how to interact with this element, and what will happen if you do interact with it.
3. **State:** What attributes about this element are subject to change? If this element is part of a field, does it have a value? Is the current value invalid? Does this field have a disabled state?
4. **Other properties:** Functional aspects of an element that would be relevant for a user or an assistive technology to be aware of, but aren't as subject to change as state. Is this element focusable with the keyboard? Does it have a longer-form description? Is this element connected to other elements in some way?

These qualities encompass everything a user might want to know about the *function* of an element, while omitting everything about the element's appearance or presentation.

## Good Markup Means Happy Trees

*Semantic markup* refers to using the native HTML elements that best reflect the desired experience. For instance, if you want an element that, when clicked, submits a form or performs some action on the page, [it's *usually* best to use a `<button>` tag](https://blog.benmyers.dev/clickable-divs/). When we write semantic HTML, the browser has a much easier time picking out the right accessible objects. Additionally, the browser can do the heavy lifting to make sure the accessible objects have all of the necessary properties, without any extra effort on our part.

However, semantics can only get us so far. Sometimes we want [newer, more complex experiences that semantic elements just don't support yet](https://developer.paciellogroup.com/blog/2014/10/aria-in-html-there-goes-the-neighborhood/#html5na), such as:

* Messaging that is subject to change, including error messages
* Tabs, tablists, and tabpanels
* Tooltips
* Toggle switches

What do we do in these cases? It's still important to engineer these experiences in ways that assistive technologies can understand. First, we get as far as we possibly can with semantic markup. Then, we use HTML's ARIA attributes to tweak the accessibility tree.

ARIA doesn't modify the DOM or add new functionality to elements. It won't change elements' behavior in any way. **ARIA exclusively manipulates elements' representation in the accessibility tree.** In other words, ARIA is used to modify an element's name, role, state, and other properties for assistive technologies.

That's great in theory, but how does it work in practice?

## Introducing the Toggle

Take a look at this toggle switch:

<!-- BAD TOGGLE -->
https://codepen.io/BenDMyers/pen/jOOReJG

If you click the toggle, you'll trigger dark mode. Click it again and you'll go back to light mode. The toggle is even keyboard-navigableâ€”you can tab to it and trigger it with Enter or Space.

It does have a bit of a problem, however. If you navigate to it with a screenreader, you'll get something like this:

<!-- UNDERWHELMING "group" SCREENSHOT -->
<WideImage
    src="/aria/group.png"
    alt={`VoiceOver announcement, which simply reads "group"`}
    caption="This is... underwhelming."
/>

Screenreader users will have no idea what this element is, or what it's for, or even that it's clickable. Users of other assistive technologies will be similarly frustrated. This is what we in the business call A Problemâ„¢. Fortunately, we can try to fix this with ARIA. We'll explore how ARIA modifies names, roles, states, and properties by adding ARIA attributes to this dark mode toggle.

If you'd like to pull the code locally to follow along, you can [clone it from GitHub](https://github.com/BenDMyers/ARIA_Toggle_Example). If you don't have a screenreader to follow along with, follow [these steps to view your browser's accessibility tree](https://blog.benmyers.dev/accessibility-tree/#from-the-dom-to-the-accessibility-tree).

Let's start with the toggle's name.

## Name

An element's <dfn>accessible name</dfn> is its label or identifier. Screenreaders announce an element's name when the user navigates to that element. Speech recognition users may also use an element's name to target that element in a voice command.

Browsers will use a variety of methods to calculate an element's name â€” and yes, [the World Wide Web Consortium has specs for that](https://www.w3.org/TR/accname-1.1/). For instance, when naming an `<img>` element, browsers will use the image's `alt` attribute, if it exists. If form fields have an associated `<label>` element, that label's contents will be used as the accessible name. Most elements' names, however, will be determined by the elements' text contents or their children's text contents. `<button>Submit</button>` will create a button with the name "Submit."

Sometimes, the strategy of using text contents isn't good enough. Some cases where manually setting the accessible name would be justified include:

* Short, repeated links like "Read more" whose context is made clear to sighted users, but which need more context to make them distinct to assistive technologies
* Icon buttons that have no meaningful text contents
* Regions of the page that should be labeled so that assistive technologies can build a skimmable page outline

ARIA offers two attributes for modifying an element's name: `aria-label` and `aria-labelledby`.

### `aria-label`

When you specify `aria-label` on an element, you override any name that element had, and you replace it with the contents of that `aria-label` attribute. In this example, we use `aria-label` to add more context to a link.

```html {numberLines: true}{3}
<a
    href="https://blog.benmyers.dev/aria"
    aria-label="Read more about ARIA"
>
    Read more...
</a>
```

This ensures that when users navigate the page using means such as the [VoiceOver Rotor](https://dequeuniversity.com/screenreaders/voiceover-keyboard-shortcuts#vo-mac-the-rotor), where links could appear out of context, this link will convey its purpose and not get lost in a sea of generic "Read more" links.

`aria-label` is particularly useful for icon buttons, such as search buttons that display a magnifying glass or close buttons that have a little <b>X</b>.

```html {numberLines: true}{1}
<button aria-label="Search">
    <svg viewBox="0 0 22 22">
        <!-- Some magnifying glass SVG icon -->
    </svg>
</button>
```

When users navigate to this button, they will hear "Close," instead of anything else that might be in the button.

`aria-label` is best used when there isn't already some visible text label on the page. Additionally, [browsers won't automatically translate `aria-label` values](https://www.heydonworks.com/article/aria-label-is-a-xenophobe) the same way it might for other foreign-language page contents.

With these caveats in mind, let's add `aria-label` to our toggle:

https://codepen.io/BenDMyers/pen/OJJGaPW

If you navigate to the switch with a screenreader now, you'll see we've already made this element much clearer:

<!-- NEW SCREENREADER XP -->
<WideImage
    src="/aria/arialabel.png"
    alt={`VoiceOver announcement, which reads "Use dark mode, group"`}
/>

*Note:* If your screenreader isn't using the new label, that could be because [screenreaders may disregard `aria-label` for static elements](http://www.davidmacd.com/blog/does-aria-label-override-static-text.html). Try circling back after the [Role](#role) section, and making sure the label works then.

### `aria-labelledby`

`aria-labelledby` differs from `aria-label` in that it's meant for cases where a text label is already present on the page. `aria-labelledby` takes a text label's `id`, and uses that label's contents as an accessible name.

For instance, we could use `aria-labelledby` to use a header as a label for a table of contents section. The `<section>` uses the heading's `id` to specify which element should serve as its label.

```html {numberLines: true}{1}
<section aria-labelledby="toc-heading">
    <h1 id="toc-heading">
        Table of Contents
    </h1>
    <ol>
        <!-- List items here -->
    </ol>
</section>
```

As a result, the whole table of contents section is named "Table of Contents."

This approach is very similar to using a `<label>` element's `for` attribute, except it works for all elements, not just form fields.

Here's what our toggle example would look like if we used `aria-labelledby` instead of `aria-label`:

https://codepen.io/BenDMyers/pen/dyyLQvY

*Note:* At this point, my VoiceOver didn't support the new label. This is because [screenreaders may disregard `aria-labelledby` for static elements](http://www.davidmacd.com/blog/does-aria-label-override-static-text.html). Try circling back after the [Role](#role) section, and making sure the label works then.

## Role

What's up with this whole "group" business?

The browser doesn't really know what to make of our toggle, or how best to expose it to assistive technology. Because our toggle is just a `<span>` with another `<span>` inside of it, the browser's best guess is that this is a generic group of elements. Unfortunately, this doesn't help users of assistive technologies understand what this element is or how they should interact with it.

We can help the browser along by providing our toggle with a `role` attribute. `role` can take [many possible values](https://www.w3.org/TR/html-aria/#aria-table) such as `button`, `link`, `slider`, or `table`. Some of these values have corresponding semantic HTML elements, but [some do not](https://developer.paciellogroup.com/blog/2014/10/aria-in-html-there-goes-the-neighborhood/#html5na).

We want to pick the role that best describes our toggle element. In our case, there are two roles that describe elements that alternate between two opposite states: `checkbox` and `switch`. These roles are functionally very similar, except that `checkbox`'s states are *checked* and *unchecked*, and `switch` uses *on* and *off*. [The `switch` role also has weaker support than `checkbox`.](https://scottaohara.github.io/a11y_styled_form_controls/src/checkbox--switch/#affects_on_sr) We'll go ahead and use `switch`, but you're free to use `checkbox` on your own.

https://codepen.io/BenDMyers/pen/BaaEeXp

When we navigate to our toggle with a screenreader now, we get a much more workable explanation of what this element is:

<WideImage
    src="/aria/role.png"
    alt={`VoiceOver announcement, which reads "Use dark mode, off, switch"`}
/>

When I lingered on this element for a bit with VoiceOver active, VoiceOver told me how I could interact with the element using the Space key:

<WideImage
    src="/aria/switch-instr.png"
    alt={`VoiceOver announcement, which instructs the user to interact with the switch by using the Space key`}
/>

Assistive technologies can now use these roles to provide extra functionalities that make navigating the page easier for disabled users. For instance, when a user issues a "click button" voice command, the Dragon NaturallySpeaking speech recognition software will light up all of the buttons on the page. Screenreaders often provide shortcuts for navigating between different elements of the same roleâ€”JAWS provides hotkeys and VoiceOver provides the Rotor for this purpose.

Importantly, [a role creates a contract](https://blog.benmyers.dev/clickable-divs/). You're promising to users that they can interact with elements in a certain way and that it will behave predictably. For instance, users will expect the following from switches:

* It can be clicked.
* It can be focused on with the keyboard.
* When the switch is focused, it can be triggered by clicking Space.
* Triggering the switch will cause something to toggle.

Specifying an element's `role` will *not* auto-magically add any of that expected functionality. It won't make our element focusable or add key events. It's up to the developer to follow through on that promise. In the case of our toggle, I've already handled this with `tabindex` and by adding a `keydown` event listener.

## State

When I navigate to our toggle with my screenreader, it tells me that it's in an "off" state. However, when I trigger the toggle... it still says it's off. We need a way to let assistive technologies know when the toggle's state has changed.

ARIA state attributes describe properties of an element that are subject to change in ways that are relevant for the user. They're dynamic. For instance, [collapsible sections](https://inclusive-components.design/collapsible-sections/) let users click a button to expand or collapse the contents. When a screenreader user is focused on that button, it would probably be helpful if they knew whether the contents were currently expanded or collapsed. We could set `aria-expanded="false"` on the button and then dynamically change the value whenever the button is clicked.

Another ARIA state attribute worth mentioning is `aria-hidden`. Whenever an element has `aria-hidden="true"`, it and any of its children are immediately removed from the accessibility tree. Assistive technologies that use the tree will have no idea that this element exists. This is useful for presentational elements that decorate the page but would create a cluttered screenreader experience. `aria-hidden` can also be dynamically toggled, e.g. to obscure page contents from screenreaders when a modal overlay is open.

Returning to our toggle, elements that have specified `role="checkbox"` or `role="switch"` expect that the element will have the `aria-checked` state attribute, and that it will alternate between `"true"` and `"false"` whenever the toggle is triggered.

The following pen demonstrates how we can use JavaScript to change `aria-checked`:

https://codepen.io/BenDMyers/pen/zYYXgOG

Try navigating to the toggle with your screenreader. Flip the switch to turn dark mode on. Now, the toggle actually announces when it's on:

<WideImage
    src="/aria/switch-state.png"
    alt={`VoiceOver announcement, which reads "on, Use dark mode, switch"`}
/>

## Properties

ARIA properties are attributes that describes extra context about an element that would be useful for a user to know, but aren't subject to change like state. Some examples include:

* Marking up form fields with `aria-required` or `aria-readonly`
* Using `aria-haspopup` to indicate that a button will open a dropdown menu
* Designating an element as a [modal](https://webdesign.tutsplus.com/articles/modal-and-modeless-boxes-in-web-design--webdesign-2282) with `aria-modal`

Some ARIA properties establish relationships between elements. For instance, you can use `aria-describedby` to link an element to another element that provides a longer-form description:

```html {numberLines: true}{8}
<form>
    <label for="pass">
        Enter a password:
    </label>
    <input
        id="pass"
        type="password"
        aria-describedby="pass-requirements"
    />
    <p id="pass-requirements">
        Your password must be at least 8 characters long.
    </p>
</form>
```

In this example, the screenreader would announce "Your password must be at least 8 characters long" as a part of the `<input>` announcement.

## Use Less ARIA.

The World Wide Web Consortium's ARIA specs provide [five rules for ARIA use](https://www.w3.org/TR/using-aria/#NOTES). The first rule isn't *quite* "Don't use ARIA," [as some have quipped](https://www.google.com/search?q=%22the+first+rule+of+aria+is+don%27t+use+aria%22), but it's pretty close:

> If you *can* use a native HTML element or attribute with the semantics and behavior you require **already built in**, instead of re-purposing an element and adding an ARIA role, state or property to make it accessible, **then do so.**

In other words, ARIA should be a tool in your arsenal, but it shouldn't be the first one you reach for. That should be semantic markup. To borrow [an analogy from Kathleen McMahon](https://noti.st/resource11/K8ARii), if web development is like cooking, then semantic elements are your high-quality ingredients and ARIA attributes are your seasonings. You only need a touch.

<!-- Practically, this means we've gone about our toggle switch the wrong way. We started by asking how ARIA could fix our switch. Instead, we should have started by asking whether we could use more appropriate HTML elements. As it turns out, we have two viable candidates. Native checkboxes (`<input type="checkbox">`) make sense, because they alternate between two opposite states, just like our toggle. We could also make a case for `<button>`, since clicking it performs an action on our page. There are [accessible solutions for checkbox switches](https://scottaohara.github.io/a11y_styled_form_controls/src/checkbox--switch/) and [for button switches](https://scottaohara.github.io/a11y_styled_form_controls/src/toggle-button-switch/) that are styled to look like our toggle switch. -->

## Conclusion

